# 数据库面试题

1. Redis可以用来做什么？Redis高并发下可能存在哪些问题？
各种应用场景详细介绍：https://juejin.cn/post/6844903906082816007

**简介**

Redis本质上也是一种键值数据库的，但它在保持键值数据库简单快捷特点的同时，又吸收了部分关系数据库的优点。从而使它的位置处于关系数据库和键值数 据库之间。Redis不仅能保存Strings类型的数据，还能保存Lists类型（有序）和Sets类型（无序）的数据，而且还能完成排序（SORT） 等高级功能，在实现INCR，SETNX等功能的时候，保证了其操作的原子性，除此以外，还支持主从复制等功能。

Redis以内存作为数据存储介质，所以读写数据的效率极高，远远超过数据库。

Redis跟memcache不同的是，储存在Redis中的数据是持久化的，断电或重启后，数据也不会丢失。因为Redis的存储分为内存存储、磁盘存储和log文件三部分，重启后，Redis可以从磁盘重新将数据加载到内存中，这些可以通过配置文件对其进行配置，正因为这样，Redis才能实现持久化。

Redis支持主从模式，可以配置集群，这样更利于支撑起大型的项目，这也是Redis的一大亮点

众多语言都支持Redis，因为Redis交换数据快，所以在服务器中常用来存储一些需要频繁调取的数据，这样可以大大节省系统直接读取磁盘来获得数据的I/O开销，更重要的是可以极大提升速度。

拿大型网站来举个例子，比如a网站首页一天有100万人访问，其中有一个板块为推荐新闻。要是直接从数据库查询，那么一天就要多消耗100万次数据库请求。上面已经说过，Redis支持丰富的数据类型，所以这完全可以用Redis来完成，将这种热点数据存到Redis（内存）中，要用的时候，直接从内存取，极大的提高了速度和节约了服务器的开销。

Redis也以消息队列的形式存在，作为内嵌的List存在，满足实时的高并发需求。而通常在一个电商类型的数据处理过程之中，有关商品，热销，推荐排序的队列，通常存放在Redis之中，期间也包扩Storm对于Redis列表的读取和更新。
**
Redis的优点**

性能极高 – Redis能支持超过 100K+ 每秒的读写频率。

丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。

原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。

丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。

**Redis的缺点**

是数据库容量受到物理内存的限制,不能用作海量数据的高性能读写,因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。

**高并发下的问题**

具体看： https://blog.csdn.net/weixin_35656078/article/details/113492394

- 缓存穿透：在实际开发中，添加缓存工具的目是减少对数据库的访问次数，增加访问效率。
   但肯定会出现Redis中不存在的缓存数据。例如：访问id=-1的数据。可能出现绕过redis依然频繁访问数据库的情况，称为缓存穿透，多出现在查询为null的情况不被缓存时。
   解决：如果查询出来为null数据，把null数据依然放入到redis缓存中，同时设置这个key的有效时间比正常有效时间更短一些。
- 缓存击穿：实际开发中，考虑redis所在服务器中内存压力，都会设置key的有效时间。一定会出现键值对过期的情况。如果正好key过期了，此时出现大量并发访问，这些访问都会去访问数据库，这种情况称为缓存击穿
   解决：重入锁。只有在第一次访问时和Key过期时才会访问数据库。
- 缓存雪崩：在一段时间内，出现大量缓存数据失效，这段时间内数据库的访问频率骤增，这种情况称为缓存雪崩。
   解决：自定义算法，例如：随机有效时间。让所有key尽量避开同一时间段。




2. 如何解决幻读？具体原理？
参考博客：https://cloud.tencent.com/developer/article/1450773
 - 脏读：A事务立即读取了B事务尚未提交的脏数据。B事务回滚数据恢复正常，但A事务带着脏数据继续执行。
 - 不可重复读：A事务两次重复读取的数据不一致。A事务耗时较长，而B事务中途更改了该数据，导致内容发生改变。
 - 幻读：A事务两次重复读取的数据总量增加。A事务耗时较长，而B事务中途新增了数据，导致总量增加。

数据库事务四大特性：ACID (atomicity, consistency, isolation & durability)
 - 原子性：事务所包含的数据库操作要么全部成功，要么全部回滚
 - 一致性：一个事务执行之前和执行之后都必须处于一致性状态
 - 隔离性：一个事务未提交的业务结果是否对于其它事务可见，有不同的隔离级别
 - 持久性：事务提交是永久操作

数据库隔离级别
- read uncommited：均不可解决
- read commited：可解决脏读；多数数据库的默认的隔离级别，如SQL Server, Oracle等
- read repeatable：可解决脏读、不可重复读；MySQL的默认隔离级别
- serializable：可解决脏读、不可重复读、幻读；事务顺序执行，但性能低，很少使用
