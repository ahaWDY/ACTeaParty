# 分布式及多线程面试题

## 1. 如何设计一个线程池？

关于线程的面试题：https://juejin.cn/post/6968721240592744455

线程池具体实现：https://zhuanlan.zhihu.com/p/356564167

线程创建和销毁的开销是很大的，需要为其分配内存，将其加入调度队列由操作系统进行调度。而线程池的目的就是减少线程的频繁创建和销毁，维持一定合理数量的线程，“需要时取，用完时还”。

线程池的基本思想为：生产者-消费者模型。使用两个链表分别表示生产者（待处理的工作任务Jobs）和消费者（包括所有线程Threads），并通过一些同步原语来协调二者之间的工作。

线程池初始化时，会创建一定数量的线程并放入Threads链表中，每个线程处理函数开启一个死循环，通过条件变量等待信号的到来；当有新的任务到来时，会加入Jobs中，并同时通过信号唤醒线程处理相应任务。

## 2. 并行和并发有什么区别？

参考博客：https://cloud.tencent.com/developer/article/1424249

并发（Concurrent），在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行

并行（Parallel），当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。

这里面有一个很重要的点，那就是系统要有多个CPU才会出现并行。在有多个CPU的情况下，才会出现真正意义上的『同时进行』。

并发，指的是多个事情，在同一时间段内同时发生了。   并行，指的是多个事情，在同一时间点上同时发生了。

并发的多个任务之间是互相抢占资源的。   并行的多个任务之间是不互相抢占资源的、

只有在多CPU的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。


## 3. 在 java 程序中怎么保证多线程的运行安全？
 
参考博客：https://www.yisu.com/ask/4484.html
- 使用安全类，比如 Java. util. concurrent 下的类。
- 使用自动锁 synchronized。
- 使用手动锁 Lock。
- 保证一个或者多个操作在CPU执行的过程中不被中断。
- 保证一个线程对共享变量的修改，另外一个线程能够立刻看到。
- 保证程序执行的顺序按照代码的先后顺序执行。

参考博客：https://blog.csdn.net/meism5/article/details/90266334

线程的安全性问题体现在：
- 原子性：一个或者多个操作在 CPU 执行的过程中不被中断的特性
- 可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到
- 有序性：程序执行的顺序按照代码的先后顺序执行

导致原因：
- 缓存导致的可见性问题
- 线程切换带来的原子性问题
- 编译优化带来的有序性问题

解决办法：
- JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题
- synchronized、volatile、LOCK，可以解决可见性问题
- Happens-Before 规则可以解决有序性问题

Happens-Before 规则如下：
- 程序次序规则：在一个线程内，按照程序控制流顺序，书写在前面的操作先行发生于书写在后面的操作
- 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作
- volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作
- 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作
- 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测
- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
- 对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始

## 4. 说一下 synchronized 底层实现原理？

参考博客：https://www.cnblogs.com/aspirant/p/11470858.html

Synchronized是Java中解决并发问题的一种最常用的方法，也是最简单的一种方法。Synchronized的作用主要有三个：

1. 原子性：确保线程互斥的访问同步代码；
2. 可见性：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的 “对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值” 来保证的；
3. 有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”；

从语法上讲，Synchronized可以把任何一个非null对象作为"锁"，在HotSpot JVM实现中，锁有个专门的名字：对象监视器（Object Monitor）。

Synchronized总共有三种用法：

1. 当synchronized作用在实例方法时，监视器锁（monitor）便是对象实例（this）；
2. 当synchronized作用在静态方法时，监视器锁（monitor）便是对象的Class实例，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个全局锁；
3. 当synchronized作用在某一个对象实例时，监视器锁（monitor）便是括号括起来的对象实例；

原理

1. monitorenter：每个对象都是一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：
   1. 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；
   2. 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1；
   3. 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；
2. monitorexit：执行monitorexit的线程必须是objectref所对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。

## 5. 什么是消息队列？

## 6. 线程的run()和start()有什么区别？

