1. 你觉得 Java 好在哪儿？

首先 Java 是跨平台的，不同平台执行的机器码是不一样的，而 Java 因为加了一层中间层 JVM ，所以可以做到一次编写多平台运行，即 「Write once, Run anywhere」。

编译执行过程是先把 Java 源代码编译成字节码，字节码再由 JVM 解释或 JIT 编译执行，而因为 JIT 编译时需要预热的，所以还提供了 AOT（Ahead-of-Time Compilation），可以直接把字节码转成机器码，来让程序重启之后能迅速拉满战斗力。（解释执行比编译执行效率差）

Java 还提供垃圾自动回收功能，虽说手动管理内存意味着自由、精细化地掌控，但是很容易出错。

在内存较充裕的当下，将内存的管理交给 GC （Carbage Collection）来做，减轻了程序员编程的负担，提升了开发效率，更加划算！

GC详细参考博客：https://blog.csdn.net/suifeng3051/article/details/48292193

现在 Java 生态圈有丰富的第三方类库、网上全面的资料、企业级框架、各种中间件等等，总之你要的都有。

2. 反射用过吗？反射的原理

参考博客：https://blog.csdn.net/m0_57541165/article/details/117922838?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4.no_search_link&spm=1001.2101.3001.4242

反射就是程序运行状态中，对于任意一个类，能够知道这个类的所有属性和方法，对于任意一个对象，能够调用方法/获取属性。

作用：对于在编译期无法确定使用哪个数据类的场景，通过反射可以在程序运行时构造出不同的数据类实例

原理：Java在编译之后会生成一个class文件，反射通过字节码文件找到其类中的方法和属性等

反射常见的应用场景：

Spring 实例化对象：当程序启动时，Spring 会读取配置文件applicationContext.xml并解析出里面所有的 标签实例化到IOC容器中。
反射 + 工厂模式：通过反射消除工厂中的多个分支，如果需要生产新的类，无需关注工厂类，工厂类可以应对各种新增的类，反射可以使得程序更加健壮。
JDBC连接数据库：使用JDBC连接数据库时，指定连接数据库的驱动类时用到反射加载驱动类

优点：增加程序的灵活性：面对需求变更时，可以灵活地实例化不同对象

缺点：破坏类的封装性：可以强制访问 private 修饰的信息；性能损耗：反射相比直接实例化对象、调用方法、访问变量，中间需要非常多的检查步骤和解析步骤，JVM无法对它们优化


3. 讲一下垃圾回收算法

详细参考博客：https://juejin.cn/post/6981812825735987208#heading-15

垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。

**怎么确定是垃圾**

**引用计数法**

给对象添加一个引用计数器，每当有一个地方引用它时，计数器加一。反之每当一个引用失效时，计数器减一。当计数器为0时，则表示对象不被引用。

**可达性分析**

设立若干根对象（GC Root），每个对象都是一个子节点，当一个对象找不到根时，就认为该对象不可达。

**标记-清除算法**

该算法先标记，后清除，遍历所有的GC Root，分别标记处可达的对象和不可达的对象，然后将不可达的对象回收。

这种算法的不足主要体现在效率和空间

从效率的角度讲，标记和清除两个过程的效率都不高,因为需要遍历所有GC ROOT.

从空间的角度讲，标记清除后会产生大量不连续的内存碎片， 内存碎片太多可能会导致以后程序运行过程中在需要分配较大对象时，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。

**复制算法**

将内存分为两块，每次只使用一块。当这一块内存满了，就将还存活的对象复制到另一块上，并且严格按照内存地址排列，然后把已使用的那块内存统一回收。

优点是：解决了标记-清除算法的碎片问题,能够得到连续的内存空间
缺点是：浪费了一半内存

**标记整理算法**

复制算法在对象存活率较高时,持续复制效率非常低,老年代都是不易被回收的对象,针对老年代的特点,可以采用标记整理算法,标记整理算法在标记-清除算法基础上,它标记之后,不直接清理,是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存.这样既避免了对象存活率较高时的持续复制,也避免了内存碎片的出现.适用于老年代.

**分代收集算法**

现代商用虚拟机基本都采用分代收集算法来进行垃圾回收。这种算法没什么特别之处，就是上面内容的结合.

它是对内存中的对象按照生命周期的长短,以及所在区域的不同进行划分.

堆区分为新生代,老年代.

方法区为持久代.

新生代就是活不了多久就死亡的对象，一般在堆内存.比如局部变量.

老年代是活的久但也会死亡的对象，一般在堆内存.比如一些生命周期长的对象.

持久代是不死的对象，一般在方法区.比如加载的class信息.

不同的年代使用不同的垃圾回收算法.

新生代使用复制算法.

老年代使用标记整理算法.

方法区的垃圾回收

持久代也就是方法区,Java虚拟机规范中说过可以不要求虚拟机在方法区实现垃圾收集，因为和堆区的垃圾回收效率相比，它的回收效率实在太低，但是此部分内存区域也是可以被回收的。

持久代和堆区的新生代和老年代不一样.方法区主要回收的内容是废弃常量和无用的类。

对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件：

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
- 加载该类的ClassLoader已经被回收；
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。.


4. 什么时候使用LinkedList?


5. 如果让你设计一个 HashMap 如何设计？

自己动手实现一个HashMap： https://winnerchen.github.io/yiheng.github.io/2017/08/26/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAHashMap/

HashMap是怎么实现的？手写一个HashMap： https://www.huaweicloud.com/articles/498753d943d56991cb9c985732be66e7.html


LeetCode 706: https://leetcode-cn.com/problems/design-hashmap/

大致分为以下几个步骤：
- Map接口：HashMap的顶层接口
  - 需要包含put, get, size方法
  - 一个内部接口Entry<K, V>（内部接口包含getKey()和getValue()两个方法）
- 内部类Entry：把内部接口Entry<K, V>实现为内部类
- 成员变量
  - 默认数组长度
  - 默认负载因子
  - Entry数组
  - HashMap的大小
- 构造器
- 哈希函数：哈希函数将任意长度的key转化为固定长度的index（散列值）。优秀的哈希算法应该保证散列值均匀，并且尽量避免冲突（不同的数据有同样的散列值）。下面列出几种，其余可以参考Hash算法原理：https://blog.csdn.net/tanggao1314/article/details/51457585
  - **生成散列值**
    - 平方取中法：H(key) = key^2 的中间几位
    - 基数转换法：变换基底
    - 除留余数法：哈希表长为m，p为小于等于m的最大素数，H(key) = key % p
  - 避免冲突
    - 开放定址法：使用再散列方法调整散列值
      - 线性探测再散列
      - 二次探测再散列
      - 伪随机探测再散列
    - 再哈希法：同时构造多个不同的哈希函数，如果冲突就使用下一个不同的哈希函数
    - 链地址法（使用**链表**）：哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中
- put方法：使用哈希函数算出index之后，用“链表”的方式把新元素添加到这个index对应的链表中去
- HashMap扩容：当map的大小大于默认长度 * 默认负载因子，那么数组的**长度会翻倍**，数组中的数据会**重新散列**然后再存放。重新散列往往是因为长度改变了，所以散列值也会发生改变。在扩容方法写好之后，需要加到put方法中调用。
- get方法：首先把key进行散列得到index，之后找到index位置的链表，再逐一比较找到真正的entry
- size方法


6. 能说下类加载过程吗
推荐：https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.md

https://blog.csdn.net/javazejian/article/details/73413292

一个类的完整生命周期包括以下几步
- 加载
- 链接（其中包括验证、准备、解析三步）
- 初始化
- 使用
- 卸载

类加载过程包括其中前三步，也就是加载、链接、初始化。类加载过程是指将Class类型文件加载到虚拟机中的过程。加载和链接的部分内容是交叉进行的

(1) 加载

- 通过包名和类名，获取类文件的二进制字节流
- 把二进制字节流映射成JVM内方法区运行时数据结构
- 在虚拟机内存中，生成一个`java.lang.Class`对象，作为这个类的访问入口。

系统类加载器：classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器

双亲委派模型：双亲委派模式要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，请注意双亲委派模式中的父子关系并非通常所说的类继承关系，而是采用组合关系来复用父类加载器的相关代码

(2) 链接

- 验证
  - 文件格式验证
  - 元数据验证
  - 字节码验证
  - 符号引用验证
- 准备：为类变量分配内存并设置初始值
- 解析：虚拟机将常量池内的符号引用替换为直接引用的过程

(3) 初始化

执行构造器`init()`；如果该类具有父类，则优先保证父类`init()`先执行，再执行子类`init()`

7. jvm如何调优，参数怎么调？如何利用工具分析jvm状态？

参数篇：https://smartan123.github.io/book/?file=001-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/002-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/0023-JVM%E8%B0%83%E4%BC%98-%E5%8F%82%E6%95%B0%E7%AF%87

工具篇：
https://www.cnblogs.com/chiangchou/p/jvm-4.html

https://blog.csdn.net/weixin_33759269/article/details/92055380

**参数**
- -server或者-client设置jvm的运行参数
  - Server VM 的初始堆空间会大一些，默认使用的是并行垃圾回收器，启动慢运行快。
  - Client VM相对来讲会保守一些，初始堆空间会小一些，使用串行的垃圾回收器，它的目标是为了让JVM的启动速度更快，但运行速度会比Serverm模式慢些。
  - JVM在启动的时候会根据硬件和操作系统自动选择使用Server还是Client类型的JVM
- -XX参数用于jvm的调优和debug操作
  - boolean类型：例如-XX:+DisableExplicitGC 表示禁用手动调用gc操作，也就是说调用 System.gc()无效
  - 非boolean类型：例如-XX:NewRatio=1 表示新生代和老年代的比值
- -Xms与-Xmx
  - -Xms设置jvm堆内存的初始大小
  - -Xmx设置jvm堆内存的最大大小

Java 8的堆内存模型
![1590290219261](https://user-images.githubusercontent.com/26801257/132763829-ed959fe8-db5c-4cdc-be9d-1910523c7f67.png)
- Young年轻区
- Tenured年老区
- MetaData本地内存空间

JVM监控分析工具一般分为两类
- JDK自带的工具调优：在jdk bin目录下面，以exe的形式直接点击就可以使用，其中包含分析工具已经很强大，几乎涉及了方方面面，但是我们最常使用的只有两款：jvisualvm.exe和jconsole.exe
  - VisualVM 是一个工具，它提供了一个可视界面，用于查看 Java 虚拟机 (Java Virtual Machine, JVM) 上运行的基于 Java 技术的应用程序（Java 应用程序）的详细信息。
  - jconsole直接在jdk/bin目录下点击jconsole.exe即可启动。在弹出的框中可以选择本机的监控本机的java应用，也可以选择远程的java服务来监控，如果监控远程服务需要在tomcat启动脚本中添加如下代码。jconsole概览图和主要的功能：概述、内存、线程、类、VM、MBeans等
```
-Dcom.sun.management.jmxremote.port=6969
-Dcom.sun.management.jmxremote.ssl=false
-Dcom.sun.management.jmxremote.authenticate=false
``` 
- 第三方分析工具：有很多，各自的侧重点不同
  - MAT(Memory Analyzer Tool)，基于Eclipse的内存分析工具
  - GCViewer
  - GCeasy
  - FastThread

8. 线程和进程的区别


